<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Asteroid</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }
        #info h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Asteroid Explorer</h2>
        <p>Drag to rotate â€¢ Scroll to zoom</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, asteroid, stars;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isDragging = false;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Create asteroid with high detail smooth geometry
            const geometry = new THREE.SphereGeometry(2, 128, 128);
            
            // Add natural random variation to vertices
            const positions = geometry.attributes.position;
            const vertexCount = positions.count;
            
            // Create many random craters
            const craterCount = 120;
            const craters = [];
            for (let i = 0; i < craterCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 2;
                
                craters.push({
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi),
                    radius: Math.random() * 0.6 + 0.15,
                    depth: Math.random() * 0.12 + 0.05
                });
            }
            
            for (let i = 0; i < vertexCount; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                
                const length = Math.sqrt(x * x + y * y + z * z);
                const nx = x / length;
                const ny = y / length;
                const nz = z / length;
                
                // Create oval shape by stretching along one axis
                const ovalFactorX = 1.3;
                const ovalFactorY = 0.85;
                const ovalFactorZ = 1.0;
                
                // Add subtle irregular bulges and rounded edges (not sharp)
                const bulge1 = Math.max(0, Math.sin(nx * 2.1 + 10) * Math.cos(ny * 1.8 + 20)) * 0.12;
                const bulge2 = Math.max(0, Math.sin(ny * 2.4 + 30) * Math.cos(nz * 2.2 + 40)) * 0.10;
                const bulge3 = Math.max(0, Math.sin(nz * 1.9 + 50) * Math.cos(nx * 2.3 + 60)) * 0.08;
                
                // Start with perfectly smooth sphere
                let displacement = 1.0 + bulge1 + bulge2 + bulge3;
                
                // Add very gentle, smooth organic shape variation
                const smooth1 = Math.sin(x * 1.3 + 17.5) * Math.cos(y * 1.5 + 23.7) * 0.04;
                const smooth2 = Math.sin(y * 1.7 + 41.2) * Math.cos(z * 1.4 + 33.8) * 0.03;
                const smooth3 = Math.sin(z * 1.2 + 52.1) * Math.cos(x * 1.6 + 61.4) * 0.02;
                
                displacement += smooth1 + smooth2 + smooth3;
                
                // Very subtle overall shape variation (no spikes, just gentle curves)
                const gentleVariation = (Math.random() - 0.5) * 0.03;
                displacement += gentleVariation;
                
                // Add many craters with very smooth, gradual falloff
                for (let j = 0; j < craters.length; j++) {
                    const crater = craters[j];
                    const dx = x - crater.x;
                    const dy = y - crater.y;
                    const dz = z - crater.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (dist < crater.radius) {
                        const craterEffect = 1 - (dist / crater.radius);
                        // Very smooth bowl-shaped crater (power of 4 for extra smoothness)
                        const craterDepth = Math.pow(craterEffect, 4) * crater.depth;
                        displacement -= craterDepth;
                        
                        // Very subtle, smooth crater rim
                        if (dist > crater.radius * 0.8) {
                            const rimEffect = (dist - crater.radius * 0.8) / (crater.radius * 0.2);
                            displacement += Math.sin(rimEffect * Math.PI) * crater.depth * 0.08;
                        }
                    }
                }
                
                // Extremely subtle micro-detail (almost imperceptible)
                const microDetail = (Math.random() - 0.5) * 0.008;
                displacement += microDetail;
                
                // Ensure smooth, positive displacement only
                displacement = Math.max(displacement, 0.7);
                
                // Apply oval shape transformation
                positions.setXYZ(
                    i, 
                    nx * displacement * 2 * ovalFactorX, 
                    ny * displacement * 2 * ovalFactorY, 
                    nz * displacement * 2 * ovalFactorZ
                );
            }
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
            
            // Create natural rocky material with smooth shading
            const material = new THREE.MeshStandardMaterial({
                color: 0x5a5a5a,
                roughness: 0.95,
                metalness: 0.05,
                flatShading: false
            });
            
            asteroid = new THREE.Mesh(geometry, material);
            asteroid.castShadow = true;
            asteroid.receiveShadow = true;
            scene.add(asteroid);
            
            // Enhanced lighting for depth
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.8);
            sunLight.position.set(5, 3, 5);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            const backLight = new THREE.DirectionalLight(0x4040ff, 0.25);
            backLight.position.set(-5, -3, -5);
            scene.add(backLight);
            
            const rimLight = new THREE.DirectionalLight(0xffa040, 0.3);
            rimLight.position.set(0, 5, -3);
            scene.add(rimLight);
            
            // Create starfield
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.05,
                transparent: true
            });
            
            const starsVertices = [];
            for (let i = 0; i < 3000; i++) {
                const x = (Math.random() - 0.5) * 100;
                const y = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
            
            // Mouse events
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            
            // Touch events for mobile
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            
            window.addEventListener('resize', onWindowResize);
        }
        
        function onMouseDown(event) {
            isDragging = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }
        
        function onMouseUp() {
            isDragging = false;
        }
        
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                isDragging = true;
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }
        
        function onTouchMove(event) {
            if (isDragging && event.touches.length === 1) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }
        
        function onTouchEnd() {
            isDragging = false;
        }
        
        function onWheel(event) {
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(3, Math.min(15, camera.position.z));
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth rotation
            if (!isDragging) {
                targetRotationY += 0.001;
            }
            
            asteroid.rotation.y += (targetRotationY - asteroid.rotation.y) * 0.1;
            asteroid.rotation.x += (targetRotationX - asteroid.rotation.x) * 0.1;
            
            // Slow starfield rotation
            stars.rotation.y += 0.0001;
            
            renderer.render(scene, camera);
        }
        
        init();
        animate();
    </script>
</body>
</html>
